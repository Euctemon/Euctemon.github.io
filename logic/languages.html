<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">

<head>
    <title>Languages</title>
    <link rel="icon" href="styles/favicon.ico" />
    <link rel="stylesheet" href="../styles/styles.css" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.27/dist/katex.min.css"
        integrity="sha384-Pu5+C18nP5dwykLJOhd2U4Xen7rjScHN/qusop27hdd2drI+lL5KvX7YntvT8yew" crossorigin="anonymous" />
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.27/dist/katex.min.js" defer="defer" crossorigin="anonymous"
        integrity="sha384-2B8pfmZZ6JlVoScJm/5hQfNS2TI/6hPqDZInzzPc8oHpN5SgeNOf4LzREO6p5YtZ"></script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.27/dist/contrib/auto-render.min.js" defer="defer"
        crossorigin="anonymous" integrity="sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh"
        onload="renderMathInElement(document.body);"></script>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="A beautiful site built with Tyxml" />
</head>

<body>
    <div class="content-flex">
        <div class="content-body">
            <h1>How to speak logic</h1>
            <h2>Languages</h2>
            <p>One way mathematicians use logic is to express ideas in other mathematical branches such as analysis or
                algebra. Almost every statement in mathematics involves quantifiers or logical connectives, and
                mathematicians need to be able to work with such statements. But they also use logic to study the
                structure of mathematics. For example, one can study the structure, length, or complexity of proofs. In
                this way mathematicians use logic to study logic itself.</p>
            <p>The question is, how do we write those statements? For that we need some notion of language. In
                mathematics, we are concerned with two things. The first one is building new things out of old ones. We
                do this using the concept of a function. The second one is describing connections between chosen things.
                We do this using the concept of a relation. Combining these two concepts, we arrive at the definition of
                a language in logic.</p>
            <div class="definition">A <span class="proof-word">language</span> is a triple \(\mathcal{L} = (\Gamma,
                \Delta, \Alpha) \) where:<ul>
                    <li>\(\Gamma\) is a set of function symbols,</li>
                    <li>\(\Delta\) is a set of relation symbols,</li>
                    <li>\(\Alpha\) is a function assigning a natural number to every function and relation symbol.</li>
                </ul>
            </div>
            <p>Hmmm, this doesn't look like a language at all. The triple \((\Gamma, \Delta, \Alpha)\) contains the
                so-called non-logical symbols, which we want to include in our theory. We will get to logical symbols
                later. The function \(\Alpha\) is called the arity function. Its domain is the set \(\Gamma \cup
                \Delta\) and its codomain is the set of natural numbers. The arity function simply describes the number
                of symbols the function or relation works with. Another common name for this triple is a signature,
                which is perhaps more fitting. Apart from these symbols, we need alphabet. For alphabet \(\Sigma\) we
                use distinct symbols called variables, parentheses, and a comma. This means that given variables
                \(\alpha,\beta\) and a function symbol \(f\) of arity two, we can construct a word \(f(\alpha,\beta)\).
                The following definition formalizes the notion of words, commonly called terms in logic.</p>
            <div class="definition">Let \(\mathcal{L} = (\Gamma, \Delta, \Alpha)\) be a language. The set of <span
                    class="proof-word">terms</span> of \(\mathcal{L}\) is the smallest set of strings over the alphabet
                \(\Sigma\) satisfying the following:<ul>
                    <li>If \(x\) is a variable, then \(x\) is a term.</li>
                    <li>If \(f\) is a function symbol of arity \(n\) and \(t_1,\ldots,t_n\) are all terms, then
                        \(f(t_1,\ldots,t_n)\) is a term.</li>
                </ul>
            </div>
            <p>The definition of a language often contains the so-called constants. Constants are simply functions of
                zero arity. The distinction between functions and constants is mostly for convenience.</p>
            <p>We now take a look at some simple languages and the terms we can write using these languages. The
                simplest language has no function or relation symbols at all. We can write such language as
                \(\mathcal{L}_\varnothing = (\varnothing, \varnothing, \Alpha)\) where \(\varnothing\) is the empty set.
                If you wonder whether the function \(\Alpha\) is well defined, then don't worry. It's perfectly fine to
                have a function with the empty set as its domain. So what are the terms of \(\mathcal{L}_\varnothing\)?
                The only way to build terms in this language is from variables. This means that terms of
                \(\mathcal{L}_\varnothing\) over a given alphabet \(\Sigma\) are exactly the variables of \(\Sigma\). If
                the alphabet does not contain any variables, then there are simply no terms.</p>
            <p>Let's make the language a little more interesting. We will write \(\mathcal{L}_1\) for a language where
                the only function symbol is \(f\) with arity one and the only relation symbol is \(r\) with arity two.
                In this language the arity function is defined as \(\Alpha(f) = 1\) and \(\Alpha(r) = 2\). To talk about
                terms, we need to specify the alphabet. Take an alphabet \(\Sigma_1\) consisting of one variable
                \(\alpha\). Having specified language and alphabet, we can start to write down the terms. For example,
                both \(\alpha\) or \(f(f(\alpha))\) are terms of this language and so is \(r(f(\alpha),\alpha)\).</p>
            <p>Terms alone are not enough to express anything meaningful. For that we need relations which give rise to
                formulas. If terms are like words, then you can think about formulas as sentences. Mathematicians even
                use the word sentence, but only for formula without free variable, which is something we will deal with
                later.</p>
            <div class="definition">Let \(\mathcal{L} = (\Gamma, \Delta, \Alpha)\) be a language. The set of <span
                    class="proof-word">atomic formulas</span> of \(\mathcal{L}\) is the smallest set of strings over the
                alphabet \(\Sigma\) satisfying the following:<ul>
                    <li>If \(r\) is a relation symbol of arity \(n\) and \(t_1,\ldots,t_n\) are all terms, then
                        \(r(t_1,\ldots,t_n)\) is an atomic formula.</li>
                </ul>
            </div>
            <p>A function can be thought of as a recipe for creating new things out of old ones. For example squaring a
                number is a function. Another example might be a cooking recipe, where the input are the ingredients and
                the output is a sweet pie of your choosing. On the other hand relations express a connection between
                things. For example two people might be relatives, friends or colleagues. In all these examples these
                two people are in some kind of relationship.</p>
            <p>How do we represent relations in mathematics? First we choose a set of things we want to talk about.
                Let's say that the set \(A = \{\alpha, \beta, \gamma, \delta, \epsilon, \pi, \omega, \zeta\}\)
                represents the greek letters we know. The set \(B = \{\pi, \omega\}\) then represents greek letters we
                like. We say that the set \(B\) defines a relation on the set \(A\). The letters \(\pi\) and \(\omega\)
                are related - we like both letters. Note that we can write a function \(f\) which specifies how to
                choose the set \(B\) from the set \(A\). The function \(f\) is simply defined as \(f(\pi) = \top\),
                \(f(\omega) = \top\) and \(\bot\) otherwise. You can thing about the symbols \(\top\), which represents
                truth, and \(\bot\), which represents falsity, as indicators whether the letter belongs to the set
                \(B\). You might think that we don't need relations at all if every relation can be written as a
                function and you are right. You can indeed just use functions. The idea is to separate function symbols
                which you want to use in the given language from symbols representing relations in order to make the
                distinction clearer.</p>
            <h2>Models</h2>
            <p>Why the definitions of terms and formulas use function symbols and relation symbols? The reason is that
                we want to have the freedom to specify the actual functions and relations later. Think about it as some
                kind of templates or interfaces in programming languages. When declaring a language \(\mathcal{L}\), you
                define the arity of function symbol \(f\) to be two, but you do not have to say whether the function
                symbol \(f\) represents addition or multiplication. The process of specifying the concrete
                implementation of language symbols is connected to an idea of a model.</p>
            <p>Suppose we want to come up with a definition of a model. This means we need to specify how to interepret
                function and relation symbols. For each function symbol, we need to have a function which will be used
                as an interpretation of the symbol. The definition of function has to contain the domain and codomain,
                or simply, what things the function takes as input and what things it produces as output. The same
                applies to relation symbols. We therefore have to specify the universe, which acts as a domain and
                codomain for all interpreted relations and functions.</p>
            <div class="definition">Fix a language \(\mathcal{L} = (\Gamma,\Delta,\Alpha)\). We say that \(\mathcal{M} =
                (\mathcal{U},\mathcal{I})\) is a <span class="proof-word">model</span> for language \(\mathcal{L}\) if
                the set \(\mathcal{U}\), commonly called universe, is a nonempty set and \(\mathcal{I}\) is a function
                which assigns to each k-ary function symbol in \(\Gamma\) a k-ary function from \(\mathcal{U}\) to
                \(\mathcal{U}\) and to each k-ary relation symbol in \(\Delta\) a k-ary relation on \(\mathcal{U}\).
            </div>
            <p>Let's take again the language \(\mathcal{L}_1\) with one function symbol and one relation symbol and a
                universe \(\mathcal{U}\) consisting of natural numbers. We will define two models for this language.
                Both models will interpret the function symbol \(f\) as adding a fixed natural number to the function's
                operand. The model \(\mathcal{M}_1\) will interpret the relation symbol as the greater or equal relation
                and the function symbol as adding number \(1\) to the argument. This can be written as \(\mathcal{M}_1 =
                (\mathbb{N}, \mathcal{I}_1)\) where \(\mathcal{I}_1(f) = (+1)\) and \(\mathcal{I}_1(r) = (\geq)\). Now
                the second model \(\mathcal{M}_2\) will interpret the relation symbol as the divisibility relation and
                the function symbol as adding the number \(3\) to the argument. We can write the second model as
                \(\mathcal{M}_2 = (\mathbb{N}, \mathcal{I}_2)\) where \(\mathcal{I}_2(f) = (+3)\) and \(\mathcal{I}_2(r)
                = (\: | \:)\).</p>
            <p> Although these models share the same language, they interpret the language in different ways. For
                example we have \(4 \geq 3\), but not \(4 \:|\: 3\). This shows that things which are true in one model
                might not necessarily be true in another. Let's interpret the atomic formula \(r(f(f(a)),b)\) in the
                first model. The term \(f(f(a))\) is interpreted as \(a + 2\) as we add the number 1 two times. We
                cannot interpret the second term any further. We conclude that the formula is interpreted as \(a + 2
                \:|\: b\). Can we say that the interpretation is true? Well it depends on how we interpret the
                variables. For example if \(a\) is \(1\) and \(b\) is \(9\), then the interpretation is true as 3
                divides 9. We conclude that we need to interpret not only function and relation symbols, but also the
                variables. The transition from variables to elements of a universe is expressed by the assignment
                function.</p>
            <div class="definition">Fix a alphabet \(\Sigma\). The assignment function \(v\) is a function from the set
                of variables in \(\Sigma\) to the universe \(\mathcal{U}\).</div>
            <p>We have seen that there exists model and an assignment function which makes the interpretation of a
                formula true. This is the example of \(r(f(f(a)),b)\). Now the interpretation of a formula \(r(a,a)\)
                given the model \(\mathcal{M}_1\) is true for any assignment function as any number is less than or
                equal to itself. We could say that this makes the formula \(r(a,a)\) more interesting than the formula
                \(r(f(f(a)),b)\) as it is independent of the assignment function. Finally a formula which is independent
                of the specification of an underlying model is even more interesting. These notions are formalized in
                the following definition.</p>
            <div class="definition">We say that the atomic formula \(\mathfrak{f}\) is:<ul>
                    <li><span class="proof-word">satisfiable</span> in the model \(\mathcal{M}\) if there exists an
                        assignment such that the formula is intepreted to \(\top\). We write this as \(\mathcal{M}
                        \vDash \mathfrak{f}[v]\).</li>
                    <li><span class="proof-word">true</span> in the model \(\mathcal{M}\) if the formula is interpreted
                        to \(\top\) for every assignment. We write this as \(\mathcal{M} \vDash \mathfrak{f}\).</li>
                    <li><span class="proof-word">valid</span> or a <span class="proof-word">semantic tautology</span> if
                        it is true in every model for a given language \(\mathcal{L}\). We write this as \(\large
                        \varnothing \normalsize \vDash \mathfrak{f}\).</li>
                </ul>
            </div>
            <p>We already met satisfiable and true formulas. It turns out that no atomic formulas can be a semantic
                tautology. Why? Because there are simply too many models. Let's say we have a formula \(\mathfrak{f}\)
                which is true in some model \(\mathcal{M}\). This means that the interpretation is true for every
                possible assignment function. Now we add another symbol to the universe \(\mathcal{M}\) and adjust the
                interpretation of relation in the language \(\mathcal{L}_1\) such that this symbol is not related to any
                other one. For example we can add the symbol \(i\) to the set of natural numbers. We will call this
                extended model \(\mathcal{M}_i\). Now we adjust the function symbol so that it is interpreted as doing
                nothing on the symbol \(i\) and the relation symbol is interpreted as false if at least one of the terms
                is interpreted as \(i\). The interpretation for other symbols for the universe is the same as in
                \(\mathcal{M}\). The formula \(\mathfrak{f}\) is not true in the extended model \(\mathcal{M}_i\)
                because of the interpretation of the symbol \(i\).</p>
            <p> We can extend this process to any language, not just \(\mathcal{L}_1\). This means that there exists no
                valid atomic formula at all. But you have probably heard of tautologies, so where is the catch? The
                answer is the introduction of logical symbols. As symbols they need to be interpreted, but they are
                interpreted in a slightly different way than function symbols or relation symbols. There are quite few
                logical symbols but our set of logical symbols will consist of \(\land\), \(\lor\), \(\to\) and \(\bot\)
                which stand for conjunction, disjunction, implication and falsity. Equipped with logical symbols, we can
                give a definition of a formula.</p>
            <div class="definition">Let \(\mathcal{L} = (\Gamma, \Delta, \Alpha)\) be a language. The set of <span
                    class="proof-word">formulas</span> of \(\mathcal{L}\) is the smallest set of strings over the
                alphabet \(\Sigma\) satisfying the following:<ul>
                    <li>\(\bot\) is a formula</li>
                    <li>If \(\mathfrak{f}\) is an atomic formula, then \(\mathfrak{f}\) is a formula</li>
                    <li>If \(\mathfrak{f}\) and \(\mathfrak{g}\) are formulas, then \(\mathfrak{f} \land \mathfrak{g}\)
                        is a formula</li>
                    <li>If \(\mathfrak{f}\) and \(\mathfrak{g}\) are formulas, then \(\mathfrak{f} \lor \mathfrak{g}\)
                        is a formula</li>
                    <li>If \(\mathfrak{f}\) and \(\mathfrak{g}\) are formulas, then \(\mathfrak{f} \to \mathfrak{g}\) is
                        a formula</li>
                </ul>
            </div>
            <p>We see that logical symbols connect formulas, which is why they are also called logical connectives. So
                why are logical symbols so special? The interpretation of logical symbol does not depend on the
                underlying model explicitly. The only important thing is whether the subformulas interpret to true or
                false.</p>
            <div class="definition">Let \(\mathcal{M} = (\mathcal{U},\mathcal{I})\) be any model. We interpret formulas
                as follows:<ul>
                    <li>The value \(\bot\) is interpreted as false.</li>
                    <li>If \(\mathfrak{g}\) and \(\mathfrak{h}\) are interpreted as true using \(\mathcal{I}\), then
                        \(\mathfrak{g} \land \mathfrak{h}\) is interpreted as true, otherwise as false.</li>
                    <li>If \(\mathfrak{g}\) or \(\mathfrak{h}\) are interpreted as true \(\mathcal{I}\), then
                        \(\mathfrak{g} \lor \mathfrak{h}\) is interpreted as true, otherwise as false.</li>
                    <li>If \(\mathfrak{g}\) is interpreted as false or \(\mathfrak{h}\) is interpreted as true using
                        \(\mathcal{I}\), then \(\mathfrak{g} \to \mathfrak{h}\) is interpreted as true, otherwise as
                        false.</li>
                </ul>
            </div>
            <p>One of the simplest tautologies is \(\mathfrak{f} \to \mathfrak{f}\). If \(\mathfrak{f}\) is interpreted
                to true, then \(\mathfrak{f} \to \mathfrak{f}\) is interpreted to true. If \(\mathfrak{f}\) is
                interpreted to false, then again \(\mathfrak{f} \to \mathfrak{f}\) is interpreted to true. This is the
                power which logical connectives hold. No matter the model and assignment function, we can form
                tautologies. Note that we do not have to include the truth symbol \(\top\) in the set of logical symbols
                as this symbol is essentially an abbreviation for tautology. What about other commonly used logical
                symbols? For example the negation \(\lnot \: \mathfrak{f}\) can be written as \(\mathfrak{f} \to \bot\).
                You can check for yourself that negation of \(\top\) is same as writing \(\top \to \bot\) and the
                negation of \(\bot\) is same as writing \(\bot \to \bot\). Similarly the biconditional implication
                \(\mathfrak{f} \equiv \mathfrak{g}\) can be written as \((\mathfrak{f} \to \mathfrak{g}) \land
                (\mathfrak{g} \to \mathfrak{f})\). This means that we can express all common logical connectives using
                just the connectives we have defined.</p>
            <h2>Truth tables</h2>
            <p>You might know that truth tables are used for propositional logic. Propositional logic is one of the
                simplest yet most known types of logic. The formulas are build from propositional variable and logical
                connectives. For variables \(a,b\) and \(c\) we can form formulas such as \((a \land b) \to c\) or
                \(\lnot(a \lor b)\). The variables represent statements which can be either true or false.</p>
            <p>Strictly speaking, such formulas do not follow our definition of how a formula is built. The problem is
                that logical connectives can only connect atomic formulas, but variables are terms. We can fix this by
                introducing a relation symbol \(r\) of arity one, which lifts variable \(a\) to an atomic formula
                \(r(a)\). The language of propositional logic thus consists of one relation symbol and no function
                symbols.</p>
            <p>The definition of propositional logic also contains the choice of a model. Equiped with the relation
                symbol, we could choose any universe and interpret the relation symbol in any way we like. Let's take
                the set \(\mathbb{Z}(i)\) of gaussian integers as our universe \(\mathcal{U}\). Gaussian integers are
                complex numbers, whose real and imaginary parts are both integers. We interpret the relation symbol as
                whether a given number is divisible by \(2 + i\). For a formula \(r(a) \land r(b)\), we choose an
                assignment function which assigns the numbers \(1 - 2i\) and \(5\) to the variables \(a\) and \(b\)
                respectively. We have \(1-2i = (2+i)(-i)\) and \(5 = (2+i)(2-i)\), which means that such assignment
                makes the formula satisfiable.</p>
            <p>The previous universe is a valid choice for a model for our language of propositional logic. However, in
                propositional logic we usually choose a model where the universe consists of two elements representing
                truth and falsity. We can denote these elements as \(\mathbf{0}\) and \(\mathbf{1}\). For a formula
                \((r(a) \lor r(b)) \to r(a)\), we have the following truth table:</p>
            <div class="table-style">
                <table>
                    <tr>
                        <td>\(v(a)\)</td>
                        <td>\(v(b)\)</td>
                        <td>\((r(a) \lor r(b)) \to r(a)\)</td>
                    </tr>
                    <tr>
                        <td>\(\mathbf{1}\)</td>
                        <td>\(\mathbf{1}\)</td>
                        <td>\(\top\)</td>
                    </tr>
                    <tr>
                        <td>\(\mathbf{1}\)</td>
                        <td>\(\mathbf{0}\)</td>
                        <td>\(\top\)</td>
                    </tr>
                    <tr>
                        <td>\(\mathbf{0}\)</td>
                        <td>\(\mathbf{1}\)</td>
                        <td>\(\bot\)</td>
                    </tr>
                    <tr>
                        <td>\(\mathbf{0}\)</td>
                        <td>\(\mathbf{0}\)</td>
                        <td>\(\top\)</td>
                    </tr>
                </table>
            </div>
            <p>We see that the relation \(r\) assign zero to false and one to true. We can skip this step and just say
                that we allow to assing truth values to variables directly. This is why the standard definitions of
                propositional logic do not mention the unary relation symbol and suppose that variables are already
                formulas with a model consisting of truth and falsity.</p>
            <p>The truth table is a nice visualization tool for a universe of with a small number of elements. For
                example with five elements and three variables, we would need to write \(5^3 = 125\) rows, which is
                impractical. In such cases, we have two options. Either we utilize computers to generate the truth
                tables, or we can use other methods such as natural deduction or sequent calculus to reason about
                formulas. The first option is connected to the branch of logic called finite model theory, which studies
                models with finite universes.</p>
            <p>We won't talk about finite model theory here, but we will look at one more example of a language with a
                finite model. Let's take a language \(\mathcal{L}_2\) with one function symbol \(f\) of arity one, and
                one relation symbol \(r\) of arity two. We will define a model \(\mathcal{M}\) where the universe
                \(\mathcal{U}\) is given by the set \(\{\alpha, \beta, \gamma\}\). The function symbol is interpreted as
                a function sending \(\alpha\) to \(\beta\), \(\beta\) to \(\gamma\) and \(\gamma\) to \(\alpha\). The
                relation symbol is interpreted as the equality relation, so \(r(\alpha, \alpha)\), \(r(\beta, \beta)\)
                and \(r(\gamma, \gamma)\) are interpreted as true and every other combination as false. We want to write
                a truth table for the formula \(r(a,f(f(b)) \equiv r(f(f(b),a)\). We denote the atomic formula
                \(r(a,f(f(b))\) as \(\mathfrak{f}\) and the atomic formula \(r(f(f(b),a)\) as \(\mathfrak{g}\). The
                truth table shows that the formula is true in this model:</p>
            <div class="table-style">
                <table>
                    <tr>
                        <td>\(v(a)\)</td>
                        <td>\(v(b)\)</td>
                        <td>\(\mathfrak{f}\)</td>
                        <td>\(\mathfrak{g}\)</td>
                        <td>\(\mathfrak{f} \equiv \mathfrak{g}\)</td>
                    </tr>
                    <tr>
                        <td>\(\alpha\)</td>
                        <td>\(\alpha\)</td>
                        <td>\(\bot\)</td>
                        <td>\(\bot\)</td>
                        <td>\(\top\)</td>
                    </tr>
                    <tr>
                        <td>\(\alpha\)</td>
                        <td>\(\beta\)</td>
                        <td>\(\top\)</td>
                        <td>\(\top\)</td>
                        <td>\(\top\)</td>
                    </tr>
                    <tr>
                        <td>\(\alpha\)</td>
                        <td>\(\gamma\)</td>
                        <td>\(\bot\)</td>
                        <td>\(\bot\)</td>
                        <td>\(\top\)</td>
                    </tr>
                    <tr>
                        <td>\(\beta\)</td>
                        <td>\(\alpha\)</td>
                        <td>\(\bot\)</td>
                        <td>\(\bot\)</td>
                        <td>\(\top\)</td>
                    </tr>
                    <tr>
                        <td>\(\beta\)</td>
                        <td>\(\beta\)</td>
                        <td>\(\bot\)</td>
                        <td>\(\bot\)</td>
                        <td>\(\top\)</td>
                    </tr>
                    <tr>
                        <td>\(\beta\)</td>
                        <td>\(\gamma\)</td>
                        <td>\(\top\)</td>
                        <td>\(\top\)</td>
                        <td>\(\top\)</td>
                    </tr>
                    <tr>
                        <td>\(\gamma\)</td>
                        <td>\(\alpha\)</td>
                        <td>\(\top\)</td>
                        <td>\(\top\)</td>
                        <td>\(\top\)</td>
                    </tr>
                    <tr>
                        <td>\(\gamma\)</td>
                        <td>\(\beta\)</td>
                        <td>\(\bot\)</td>
                        <td>\(\bot\)</td>
                        <td>\(\top\)</td>
                    </tr>
                    <tr>
                        <td>\(\gamma\)</td>
                        <td>\(\gamma\)</td>
                        <td>\(\bot\)</td>
                        <td>\(\bot\)</td>
                        <td>\(\top\)</td>
                    </tr>
                </table>
            </div>
        </div>
    </div>
    <div class="left-right-nav"><a href="../logic/introduction.html"><svg xmlns="http://www.w3.org/2000/svg"
                xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 3 30 30" width="35px" height="35px">
                <path d="M 19 9 L 13 15 L 19 21" fill="none" stroke="currentColor" stroke-linecap="round"
                    stroke-linejoin="round" stroke-width="3px"></path>
            </svg></a><a href="../blog.html">Blog</a><a href="../logic/proofsystems.html"><svg
                xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 3 30 30"
                width="35px" height="35px">
                <path d="M 12 9 L 18 15 L 12 21" fill="none" stroke="currentColor" stroke-linecap="round"
                    stroke-linejoin="round" stroke-width="3px"></path>
            </svg></a></div>
</body>

</html>