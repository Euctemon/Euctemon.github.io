<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <link rel="stylesheet" href="styles.css">
  <link rel="icon" href="favicon.svg">

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">

  <!-- The loading of KaTeX is deferred to speed up page rendering -->
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js" integrity="sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4" crossorigin="anonymous"></script>

  <!-- To automatically render math in text elements, include the auto-render extension: -->
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js" integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa" crossorigin="anonymous" onload="renderMathInElement(document.body);"></script>

  <title>Groups and Fields</title>
</head>

<body>
    <header>
        Groups and fields
    </header>

    <div class="main-article">
        <div class="mainnav">
        <div class="nav-item">
        <div class="nav-heading"><a href="index.html">Home</a></div>
        <div class="nav-heading">Groups and fields</div>
        <nav>
            <ul>
                <li><a href="fields_intro.html">Introduction</a></li>
                <li><a href="fields_monoid.html">Monoids</a></li>
            </ul>
        </nav>
        </div>
        </div>

        <div class="sidenav">
        <div class="nav-item">
        <div class="nav-heading">Table of content</div>
        <nav>
            <ul>
            <li><a href="#keepitsimple">Keep it simple</a></li>
            <li><a href="#commutmonoids">Commutative monoids</a></li>
            </ul>
        </nav>
        </div>
        </div>
    
        <div class="content">
            <article>
                <h2 id="keepitsimple">Keep it simple</h2>
                <p>
                    We start with a fairly simple algebraic structure called monoid. A monoid is just a set with one binary operation and one unique element called identity. The operation being binary just means that the operation takes two elements from the set and assign to them one specific element also in the set. This operation can be addition or multiplication but not only. For example string concatenation is also a valid binary operation taking two strings and producing another string. The name of identity element depends on the binary operation. For addition we take the identity to be a zero, for multiplication an one and for string concatenation a empty string. The formal definition of monoid is surely shorter than that of a field
                </p>

                <div class="definition">
                    <p>
                        Monoid is a set \(R\) with a binary operation \(\odot : R \rightarrow R \rightarrow R\) and an element \(1 \in R\) such that they satisfy following axioms
                        <ul>
                            <li>\(\forall \, a,b \in R\) we have \(a \odot b \in R\)</li>
                            <li>\(\forall \, a,b,c \in R\) we have \((a \odot b) \odot c = a \odot (b \odot c)\)</li>
                            <li>\(\forall \, a \in R\) we have \(a \odot 1 = a\)</li>
                            <li>\(\forall \, a \in R\) we have \(1 \odot a = a\)</li>
                        </ul>
                    </p>
                </div>

                <p>
                    Throughout all the chapters I will be using the theorem prover called <a href="https://lean-lang.org/">LEAN</a>. There is a lot of software for program verification and writing mathematical proofs, for example Coq, Isabelle, Prover9 and so on. What makes LEAN special for me personally is that it is a modern software and also a fully featured functional language. So let's go programming, or should I say proving? Here is how the definition of monoid looks in LEAN
                </p>


<div class="code">
<pre>
class mul_monoid (α : Type) where
    mul : α → α → α
    one : α
    mul_assoc : ∀ a b c : α, mul a (mul b c) = mul (mul a b) c
    mul_one_right : ∀ a : α, mul a one = a
    mul_one_left : ∀ a : α, mul one a = a
</pre>
</div>

                <p>
                    The LEAN prover is based on higher order type theory and we will bump into the codeword type quite often. This doesn't need to bother you as we will focus just on the mathematics. For anyone who knows LEAN and accidentaly reads this - at the time of writing these chapters I am not proficient in LEAN and that means I will be using the prover in the most basic way. This means that sometimes I will have to type more than it would be necessary. On the other hand it might have the advantage that not much will be hidden in some obscure syntax or rules. Now is the time to prove that the identity we need in the definition of a monoid is unique.
                </p>

<div class="code">
<pre>
namespace mul_monoid

example {α : Type} [mul_monoid α] (b : α) (h : ∀ a, mul a b = a) : b = (one : α) := by
    have : mul one b = one := h one
    rw [mul_one_left] at this
    exact this
</pre>
</div>

            <h2 id="commutmonoids">Commutative monoids</h2>
            <p>
                The binary operation specified in the definition of a monoid does not need to be commutative. This means that for any elements \(a\) and \(b\) in the monoid it holds that \(a \odot b = b \odot a\). How can we tell this to LEAN? One way is to define the commutative monoid from the ground up as follows

<div class="code">
<pre>
class comm_mul_monoid_whole (α : Type) where
    mul : α → α → α
    one : α
    mul_assoc : ∀ a b c : α, mul a (mul b c) = mul (mul a b) c
    mul_one_right : ∀ a : α, mul a one = a
    mul_comm : ∀ a b : α, mul a b = mul b a
</pre>
</div>

            <p>
                You might notice a little thing missing here. Where did <span class="code-inline">mul_one_left</span> go? We don't need it as we can prove it holds. We just use the axiom <span class="code-inline">mul_one_right</span> and then use the commutativity of the binary operation <span class="code-inline">mul_comm</span>. It can be formalized as follows
            </p>

<div class="code">
<pre>
namespace comm_mul_monoid'

example {α : Type} [comm_mul_monoid' α] (a : α) : mul (one : α) a = a := by
    rw [mul_comm one]
    rw [mul_one_right]    
</pre>
</div>







            <p>
                This is certainly possible but there is a better way. We can use the monoid definition to build up the definition for a commutative monoid as follows
            </p>
<div class="code">
<pre>
class comm_mul_monoid (α : Type) extends mul_monoid α where
    mul_comm : ∀ a b : α, mul a b = mul b a
</pre>
</div>



            </p>
            </article>
        </div>
        </div>
</body>