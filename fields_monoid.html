<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <link rel="stylesheet" href="styles.css">
  <link rel="icon" href="favicon.svg">

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">

  <!-- The loading of KaTeX is deferred to speed up page rendering -->
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js" integrity="sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4" crossorigin="anonymous"></script>

  <!-- To automatically render math in text elements, include the auto-render extension: -->
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js" integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa" crossorigin="anonymous" onload="renderMathInElement(document.body);"></script>

  <title>Groups and Fields</title>
</head>

<body>
    <header>
        Groups and fields
    </header>

    <div class="main-article">
        <div class="mainnav">
        <div class="nav-item">
        <div class="nav-heading"><a href="index.html">Home</a></div>
        <div class="nav-heading">Groups and fields</div>
        <nav>
            <ul>
                <li><a href="fields_intro.html">Introduction</a></li>
                <li><a href="fields_monoid.html">Monoids</a></li>
            </ul>
        </nav>
        </div>
        </div>

        <div class="sidenav">
        <div class="nav-item">
        <div class="nav-heading">Table of content</div>
        <nav>
            <ul>
            <li><a href="#monoids">Monoids</a></li>
            <li><a href="#comm-monoids">Commutative monoids</a></li>
            <li><a href="#groups">Groups</a></li>
            </ul>
        </nav>
        </div>
        </div>
    
        <div class="content">
            <article>
                <h2 id="monoids">Monoids</h2>
                <p>
                    We start with a fairly simple algebraic structure called monoid. A monoid is just a set with one binary operation and one unique element called identity. The operation being binary just means that the operation takes two elements from the set and assign to them one specific element also in the set. This operation can be addition or multiplication but not only. For example string concatenation is also a valid binary operation taking two strings and producing another string. The name of identity element depends on the binary operation. For addition we take the identity to be a zero, for multiplication an one and for string concatenation a empty string. The formal definition of monoid is surely shorter than that of a field
                </p>

                <div class="definition">
                    <p>
                        Monoid is a set \(R\) with a binary operation \(\odot : R \rightarrow R \rightarrow R\) and an element \(1 \in R\) such that they satisfy following axioms
                        <ul>
                            <li>\(\forall \, a,b \in R\) we have \(a \odot b \in R\)</li>
                            <li>\(\forall \, a,b,c \in R\) we have \((a \odot b) \odot c = a \odot (b \odot c)\)</li>
                            <li>\(\forall \, a \in R\) we have \(a \odot 1 = a\)</li>
                            <li>\(\forall \, a \in R\) we have \(1 \odot a = a\)</li>
                        </ul>
                    </p>
                </div>

                <p>
                    Throughout all the chapters I will be using the theorem prover called <a href="https://lean-lang.org/">LEAN</a>. There is a lot of software for program verification and writing mathematical proofs, for example Coq, Isabelle, Prover9 and so on. What makes LEAN special for me personally is that it is a modern software and also a fully featured functional language. So let's go programming, or should I say proving? Here is how the definition of monoid looks in LEAN
                </p>


<div class="code">
<pre>
class mul_monoid (α : Type) where
    mul : α → α → α
    one : α
    mul_assoc : ∀ a b c : α, mul a (mul b c) = mul (mul a b) c
    mul_one_right : ∀ a : α, mul a one = a
    mul_one_left : ∀ a : α, mul one a = a
</pre>
</div>

                <p>
                    The LEAN prover is based on higher order type theory and we will bump into types quite often. This doesn't need to bother you as we will focus just on the mathematics. For anyone who knows LEAN and accidentaly reads this - at the time of writing these chapters I am not proficient in LEAN and that means I will be using the prover in the most basic way. This means that sometimes I will have to type more than it would be necessary. On the other hand it might have the advantage that not much will be hidden in some obscure syntax or rules. Now is the time to prove that the identity we need in the definition of a monoid is unique.
                </p>

<div class="code">
<pre>
namespace mul_monoid

example {α : Type} [mul_monoid α] (b : α) (h : ∀ a, mul a b = a) : b = (one : α) := by
    have : mul one b = one := h one
    rw [mul_one_left] at this
    exact this
</pre>
</div>

            <p>
                With only the definition at hand we cannot prove anything interesting about the monoid structure. The good stuff happens when we start talking about monoid morphism. I will not talk about morphisms in this text. So is that it? Well if we can say something about an element such that it has an inverse element then we can sometimes discover another property the element satisfies. First we need a technical lemma which is mathematically trivial. If for elements \(a,b,c \in R\) it holds that \(a = b\) then surely \(c \odot a = c \odot b\). Luckily there is no problem telling this to lean
            </p>

<div class="code">
<pre>
theorem left_mul {α : Type} [mul_monoid α] (a b : α) (h : a = b) : ∀ c : α, mul c a = mul c b := by
    intro c
    have : mul c a = mul c a := rfl
    rw [h]
</pre>
</div>

    <p>
        So back to the inverse elements. In the context of monoid it does not generally hold that \(c \odot a = c \odot b\) implies \(a = b\). You cannot mindlessly cancel the element \(c\). But you can do that if there exists and inverse element for \(c\). By that it is meant there exists such \(d\) so \(d \odot c = 1\). As we have not yet stated that the binary operation is multiplicative we need to be careful and say that \(c\) has a left inverse. Now we can prove that if an element has a left inverse then you can cancel it from left
    </p>

<div class="code">
<pre>
theorem left_cancel {α : Type} [mul_monoid α] (a b c : α) (h : ∃ d, mul d c = one) : mul c a = mul c b → a = b := by
    intro hc
    apply Exists.elim h
    intro d hd
    have : mul d (mul c a) = mul d (mul c b) := by
    apply left_mul
    exact hc
    repeat (rw [mul_assoc, hd, mul_one_left] at this)
    exact this
</pre>
</div>



            <h2 id="comm-monoids">Commutative monoids</h2>
            <p>
                The binary operation specified in the definition of a monoid does not need to be commutative. This means that for any elements \(a\) and \(b\) in the monoid it holds that \(a \odot b = b \odot a\). How can we tell this to LEAN? One way is to define the commutative monoid from the ground up as follows
            </p>

<div class="code">
<pre>
class comm_mul_monoid_whole (α : Type) where
    mul : α → α → α
    one : α
    mul_assoc : ∀ a b c : α, mul a (mul b c) = mul (mul a b) c
    mul_one_right : ∀ a : α, mul a one = a
    mul_comm : ∀ a b : α, mul a b = mul b a
</pre>
</div>

            <p>
                You might notice a little thing missing here. Where did <span class="code-inline">mul_one_left</span> go? We don't need it as we can prove it holds. We just use the axiom <span class="code-inline">mul_one_right</span> and then use the commutativity of the binary operation <span class="code-inline">mul_comm</span>. It can be formalized as follows
            </p>

<div class="code">
<pre>
namespace comm_mul_monoid'

example {α : Type} [comm_mul_monoid' α] (a : α) : mul (one : α) a = a := by
    rw [mul_comm one]
    rw [mul_one_right]    
</pre>
</div>

            <p>
                This is certainly possible but there is a better way. We can use the monoid definition to build up the definition for a commutative monoid as follows
            </p>
<div class="code">
<pre>
class comm_mul_monoid (α : Type) extends mul_monoid α where
    mul_comm : ∀ a b : α, mul a b = mul b a
</pre>
</div>


            <h2 id="groups">Groups</h2>
            <p>
                Earlier we saw that if an element had an inverse we could deduce additional algebraic properties like left cancelation. What if every element in a given monoid has an inverse? We get a an algebraic structure called group. I will again state a plain-text definition and then we will look how to encode it in Lean. The typical definition people hear is this
            </p>

            <div class="definition">
                <p>
                    Group is a set \(R\) with a binary operation \(\odot : R \rightarrow R \rightarrow R\) and an element \(1 \in R\) such that they satisfy following axioms
                    <ul>
                        <li>\(\forall \, a,b \in R\) we have \(a \odot b \in R\)</li>
                        <li>\(\forall \, a,b,c \in R\) we have \((a \odot b) \odot c = a \odot (b \odot c)\)</li>
                        <li>\(\forall \, a \in R\) we have \(a \odot 1 = a\)</li>
                        <li>\(\forall \, a \in R\) we have \(1 \odot a = a\)</li>
                        <li>\(\forall \, a \in R \enspace \exists \, b \in R\) such that \(b \odot a = 1\)</li>
                    </ul>
                </p>
            </div>

            <p>
                The second definition is both shorter and I would say even clearer
            </p>

            <div class="definition">
                <p>
                    Group is a monoid \((R,\odot)\) where every element has its left inverse. This means
                    <ul>
                        <li>\(\forall \, a \in R \enspace \exists \, b \in R\) such that \(b \odot a = 1\)</li>
                    </ul>
                </p>
            </div>

            <p>
                Are we bothered with the fact that we did not explicitly said that the element shoul have also right inverse? It is not so pleasant exercise to show that indeed if a group element has a left inverse \(b\) then \(b\) is also a right inverse. For this to prove we need a group structure. You might be tempted to recycle the lemma about left cancelation in monoids. There we assumed that a specific element had a left inverse and proved the left cancelation property. But from the fact that one element has a left inverse you cannot prove it is also its right inverse. You need to assume that all elements have a left inverse! The proof requires a little lemma about idempotence of inverses
            </p>
            
<div class="code">
<pre>
namespace mul_monoid
postfix:max "⁻¹" => mul_group.inv
    
theorem inv_idemp {α : Type} [mul_group α] (a : α) : mul (mul a a⁻¹) (mul a a⁻¹) = (mul a a⁻¹) := by
    rw [mul_assoc]
    rw [← mul_assoc a a⁻¹ a]
    rw [mul_group.inv_left]
    rw [mul_one_right]
    
theorem inv_right {α : Type} [mul_group α] (a : α) : mul a a⁻¹ = one := by
    calc mul a a⁻¹ = mul one (mul a a⁻¹) := Eq.symm (mul_one_left (mul a a⁻¹))
         _ = mul (mul (mul a a⁻¹)⁻¹ (mul a a⁻¹)) (mul a a⁻¹) := by rw [mul_group.inv_left (mul a a⁻¹)]
         _ = mul (mul a a⁻¹)⁻¹ (mul (mul a a⁻¹) (mul a a⁻¹)) := by rw [mul_assoc ((mul a a⁻¹)⁻¹) (mul a a⁻¹) (mul a a⁻¹)]
         _ = mul (mul a a⁻¹)⁻¹ (mul a a⁻¹) := by rw [inv_idemp]
         _ = one := by rw [mul_group.inv_left]
</pre>
</div>

        <p>
            This is it. We proved that in a group, if an element \(a\) has a left inverse \(b\) then this exact \(b\) is also a right inverse. Beware that although for \(a \odot b = 1\) it holds that \(a \odot b = b \odot a\) it does not mean that the binary operation is commutative. This holds just for the element inverses.
        </p>

        </article>
        </div>
        </div>
</body>