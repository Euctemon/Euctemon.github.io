<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <link rel="stylesheet" href="styles.css">
  <link rel="icon" href="favicon.svg">

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">

  <!-- The loading of KaTeX is deferred to speed up page rendering -->
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js" integrity="sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4" crossorigin="anonymous"></script>

  <!-- To automatically render math in text elements, include the auto-render extension: -->
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js" integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa" crossorigin="anonymous" onload="renderMathInElement(document.body);"></script>

  <title>Groups and Fields</title>
</head>

<body>
    <header>
        Groups and fields
    </header>

    <div class="main-class">
        <div class="mainnav">
            <div class="nav-item">
                <div class="nav-heading"><a href="index.html">Home</a></div>
                <div class="nav-heading">Groups and fields</div>
                <nav>
                    <ul>
                        <li><a href="fields_intro.html">Introduction</a></li>
                        <li><a href="fields_monoid.html">Monoids</a></li>
                    </ul>
                </nav>
            </div>
        </div>

        <div class="sidenav">
            <div class="nav-item">
                <div class="nav-heading">Table of content</div>
                <nav>
                    <ul>
                    <li><a href="#monoids">Monoids</a></li>
                    <li><a href="#groups">Groups</a></li>
                    </ul>
                </nav>
            </div>
        </div>
    
        <div class="content">
            <article>
                <h2 id="monoids">Monoids</h2>
                <p>
                    We start with a simple algebraic structure called monoid. A monoid is just a set with one binary operation and one unique element called identity. The operation being binary just means that the operation takes two elements from the set and assign to them one specific element also in the set. This operation can be addition or multiplication but not only. For example string concatenation is also a valid binary operation taking two strings and producing another string. The name of identity element depends on the binary operation. For addition we take the identity to be the number zero, for multiplication the number one and for string concatenation the empty string. The formal definition of monoid is surely shorter than that of a field
                </p>

                <div class="definition">
                    <p>
                        Monoid is a set \(R\) with a binary operation \(\odot : R \rightarrow R \rightarrow R\) and an element \(1 \in R\) such that they satisfy following axioms
                    </p>
                    <ul>
                        <li>\(\forall \, a,b,c \in R\) we have \((a \odot b) \odot c = a \odot (b \odot c)\)</li>
                        <li>\(\forall \, a \in R\) we have \(a \odot 1 = a\)</li>
                        <li>\(\forall \, a \in R\) we have \(1 \odot a = a\)</li>
                    </ul>
                </div>

                <p>
                    When you want to define a very simple algebraic structure there axioms seems to be a good choice. First there is the associativity of the binary operation. It would be weird if something like \((a \odot a) \odot a = a \odot (a \odot a)\) wouldn't hold. The other two axioms specifies how the element \(1\) plays with the binary operation. If we just stated that there is a specific element in the set but we wouldn't know its behaviour would the element be really special? You are free to come up with almost any axioms for your structure. You can state just the associativity of the binary operation and nothing more. Then it would be called semigroup. Or if you really want you do not need to specify the associative property. But in these cases you end up with a structure which is hard to reason about as you cannot say almost anything about that structure. Now we will look at how to define monoids in LEAN. The definition is almost one to one copy of the written one. You can see that the the operations and axioms are bundled together. The mathematical definition is oblivious of the naming of the binary operation as long as the operation satisfy the axioms. Nevertheless we will be working with either the multiplication od addition and so I will name them in the code.
                </p>

<div class="code">
<pre>
class mul_monoid (α : Type) where
    mul : α → α → α
    one : α
    mul_assoc : ∀ a b c : α, mul a (mul b c) = mul (mul a b) c
    mul_one_right : ∀ a : α, mul a one = a
    mul_one_left : ∀ a : α, mul one a = a
</pre>
</div>

                <p>
                    So what can we do with it? The first thing is that we will prove the uniqueness of the element \(1\). The proof of this fact is rather simple. Let's say that we have an element \(b\) such that if we choose an arbitrary element \(a\) then \(a \odot b = 1\). We can then choose \(1\) as the element \(a\) and then use the axiom of multiplying an element by \(1\) on the left side to arrive to the conclusion that \(b = 1\). Everything up to the lonely <span class="code-inline">:</span> is an assumption. You might be stumped by the expression  <span class="code-inline">M : mul_monoid α</span>. This means that \(M\) is a monoid with the underlying type \(\alpha\). When we speak about monoids we need to specify the underlying set. In the definition that was what the letter \(R\) stands. In the LEAN definition we treated the variable \(\alpha\) as something like the set \(R\). The problem is that variable \(\alpha\) is a type. There is a difference but at this point it won't cause any trouble. If you are bothered by this you can read the chapter on <a href="https://leanprover-community.github.io/mathematics_in_lean/C04_Sets_and_Functions.html">sets</a> from the book on mathematics in LEAN I mentioned earlier.
                </p>

<div class="code">
<pre>
namespace mul_monoid

example {α : Type} [M : mul_monoid α] (b : α) (h : ∀ a, mul a b = a) : b = (one : α) := by
    have : mul one b = one := h one
    rw [mul_one_left] at this
    exact this
</pre>
</div>

                <p>
                    With so little axioms at our disposal we cannot prove anything interesting about the monoid structure alone. There is one thing which uses just the definition of the monoid operation. The next theorem is literally just expressing the fact that we can actually use the monoid operation. In other words if \(a = b\) then it is also true that \(c \odot a = c \odot b\) for an arbitrary element \(c\)
                </p>

<div class="code">
<pre>
theorem left_mul {α : Type} [M : mul_monoid α] (a b : α) (h : a = b) : ∀ c : α, mul c a = mul c b := by
    intro c
    have : mul c a = mul c a := rfl
    rw [h]
</pre>
</div>

                <p>
                    With another assumption on a specific element we can prove something little more interesting. In the context of monoid it does not generally hold that \(c \odot a = c \odot b\) implies \(a = b\). You cannot mindlessly cancel the element \(c\). But you can do that if there exists and inverse element for \(c\). By that it is meant there exists such \(d\) so \(d \odot c = 1\). As we have not yet stated that the binary operation is multiplicative we need to be careful and say that \(c\) has a left inverse. Now we can prove that if an element has a left inverse then you can cancel it from left
                </p>

<div class="code">
<pre>
theorem left_cancel {α : Type} [M : mul_monoid α] (a b c : α) (h : ∃ d, mul d c = one) : mul c a = mul c b → a = b := by
    intro hc
    apply Exists.elim h
    intro d hd
    have : mul d (mul c a) = mul d (mul c b) := by
    apply left_mul
    exact hc
    repeat (rw [mul_assoc, hd, mul_one_left] at this)
    exact this
</pre>
</div>

                <p>
                    We will end the initial discussion of monoids with another interesting fact. If an element has both left inverse and right inverse then these inverses are identical. You might think that this is obvious but do not forget that we did not say that our binary operation is commutative! So proving this will cost us few lines.
                </p>


<div class="code">
<pre>
theorem left_right_inv {α : Type} [M : mul_monoid α] (a b c : α) (h : mul a b = one ∧ mul c a = one) : b = c := by
    calc b = mul one b := by rw [mul_one_left]
         _ = mul (mul c a) b := by rw [h.right]
         _ = mul c (mul a b) := by rw [mul_assoc]
         _ = mul c one := by rw [h.left]
         _ = c := by rw [mul_one_right]
</pre>
</div>

                <h2 id="groups">Groups</h2>
                <p>
                    Earlier we saw that if an element had an inverse we could deduce additional algebraic properties like left cancelation. What if every element in a given monoid has an inverse? We get a an algebraic structure called group. I will again state a plain-text definition and then we will look how to encode it in Lean. The typical definition you will encounter will not use the word monoid and just list all the axioms as we did with the definition of a field.
                </p>

                <div class="definition">
                    <p>
                        Group is a set \(R\) with a binary operation \(\odot : R \rightarrow R \rightarrow R\) and an element \(1 \in R\) such that they satisfy following axioms
                    </p>
                    <ul>
                        <li>\(\forall \, a,b \in R\) we have \(a \odot b \in R\)</li>
                        <li>\(\forall \, a,b,c \in R\) we have \((a \odot b) \odot c = a \odot (b \odot c)\)</li>
                        <li>\(\forall \, a \in R\) we have \(a \odot 1 = a\)</li>
                        <li>\(\forall \, a \in R\) we have \(1 \odot a = a\)</li>
                        <li>\(\forall \, a \in R \enspace \exists \, b \in R\) such that \(b \odot a = 1\)</li>
                    </ul>
                </div>

                <p>
                    Our main job is to see how are the algebraic structures interconnected in hope to understand them better. The definition of a group stated as follows literally screams that a group is a really nice monoid when looking at the inverse elements.
                </p>

                <div class="definition">
                    <p>
                        Group is a monoid \((R,\odot)\) where the following axiom holds
                    </p>
                        <ul>
                            <li>\(\forall \, a \in R \enspace \exists \, b \in R\) such that \(b \odot a = 1\)</li>
                        </ul>
                </div>

                <p>
                    We can now define a group structure in LEAN and we will do it using the second version of the group definition
                </p>

<div class="code">
<pre>
class mul_group (α : Type) extends mul_monoid α where
    inv : α → α
    inv_left : ∀ a : α, mul (inv a) a = one  
</pre>
</div>

                <p>
                    Again there is a little clash of types and sets. The LEAN definition states that the group features a unary operation called inverse which satisfy the inverse axiom. The part <span class="italic">there exists</span> in the statement of the axiom is hidden here. But again you do not need to worry about that.
                    But we should definetely be bothered by the fact that we did not explicitly said that the element should also have a right inverse. It is not so pleasant exercise to show that indeed if a group element has a left inverse \(b\) then it has also an right inverse and it is the same \(b\). For this to prove we need a group structure. You might be tempted to say that we already proved that. Well we proved that if and element has both inverses then they must be identical. Now we are trying to prove that just from the assumption of the existence of the left inverse we want to prove the existence of the right inverse and that the left and right inverses are identical. The proof requires a little lemma about the behaviour of inverses
                </p>

<div class="code">
<pre>
namespace mul_monoid
postfix:max "⁻¹" => mul_group.inv
    
theorem inv_idemp {α : Type} [mul_group α] (a : α) : mul (mul a a⁻¹) (mul a a⁻¹) = (mul a a⁻¹) := by
    rw [mul_assoc]
    rw [← mul_assoc a a⁻¹ a]
    rw [mul_group.inv_left]
    rw [mul_one_right]
</pre>
</div>

                <p>
                    You can see that i defined a postfix for the group inverse. This is one of the times I will cheat and not write the expression <span class="code-inline">mul_group.inv</span> because the code would be too cluttered by this. Of course you can write the full expression and do not try to setup the postfix style of the inverse operator.
                </p>

<div class="code">
<pre>
        
theorem inv_right {α : Type} [mul_group α] (a : α) : mul a a⁻¹ = one := by
    calc mul a a⁻¹ = mul one (mul a a⁻¹) := Eq.symm (mul_one_left (mul a a⁻¹))
         _ = mul (mul (mul a a⁻¹)⁻¹ (mul a a⁻¹)) (mul a a⁻¹) := by rw [mul_group.inv_left (mul a a⁻¹)]
         _ = mul (mul a a⁻¹)⁻¹ (mul (mul a a⁻¹) (mul a a⁻¹)) := by rw [mul_assoc ((mul a a⁻¹)⁻¹) (mul a a⁻¹) (mul a a⁻¹)]
         _ = mul (mul a a⁻¹)⁻¹ (mul a a⁻¹) := by rw [inv_idemp]
         _ = one := by rw [mul_group.inv_left]
</pre>
</div>

        </article>
        </div>
        </div>
</body>