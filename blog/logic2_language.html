<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <link rel="stylesheet" type="text/css" href="../styles/styles.css">
    <link rel="icon" href="../styles/favicon.ico">
    

    <!-- Katex extension -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css" integrity="sha384-nB0miv6/jRmo5UMMR1wu3Gz6NLsoTkbqJghGIsx//Rlm+ZU03BU6SQNC66uf4l5+" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js" integrity="sha384-7zkQWkzuo3B5mTepMUcHkMB5jZaolc2xDwL6VFqjFALcbeS9Ggm/Yr2r3Dy4lfFg" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/auto-render.min.js" integrity="sha384-43gviWU0YVjaDtb/GhzOouOXtZMP/7XUzwPTstBeZFe/+rCMvRwr4yROQP43s0Xk" crossorigin="anonymous"
        onload="renderMathInElement(document.body);"></script>

    <script type="text/javascript" src="../styles/buttons.js"></script>
    
    <title>Logic</title>
</head>

<body>
    <button onclick="navOpener()" id="blog-button">
        <svg xmlns="http://www.w3.org/2000/svg" width="30" height="30">
            <circle r="1.2" cx="6" cy="10" stroke="black"/>
            <circle r="1.2" cx="6" cy="16" stroke="black"/>
            <circle r="1.2" cx="6" cy="22" stroke="black"/>
            <line x1="12" y1="10" x2="25" y2="10" stroke="black" stroke-width="2" stroke-linecap="round"/>
            <line x1="12" y1="16" x2="25" y2="16" stroke="black" stroke-width="2" stroke-linecap="round"/>
            <line x1="12" y1="22" x2="25" y2="22" stroke="black" stroke-width="2" stroke-linecap="round"/>
        </svg>
    </button>

    <header>
    <div id="blog-nav">
        <ul>
            <li><a href="../blog.html">Blog</a></li>
            <li><a href="logic1_intro.html">Introduction</a></li>
            <li><a href="logic2_language.html">Languages</a></li>
            <li><a href="logic3_proving.html">Proof systems</a></li>
            <li><a href="logic4_completeness.html">Completeness</a></li>
            <li><a href="logic5_natural.html">Natural deduction</a></li>
        </ul>
    </div>
    </header>

    <div class="blogpage">
        <h2>Languages</h2>
        <h3>What constitutes a language</h3>

        <p>
            In the introduction, we noted that logic is concerned with the problem of correct ways of reasoning. Informal logic deals with critical thinking, unravelling fallacies, and constructing sound arguments in natural language. Mathematicians are not brave enough to tackle this problem in its full generality and leave it to philosophers and linguists. They turn their attention to formal logic and formal languages. Such languages have strict rules, which enable unambiguous interpretation. Let's take the law of excluded middle as an example. Philosophers debate whether it should or should not be a law. Mathematicians either involve such a statement in the formal system or not.
        </p>

        <p>
            One way mathematicians use logic is to express ideas in other mathematical branches such as analysis or algebra. Almost every statement in mathematics involves quantifiers or logical connectives, and mathematicians need to be able to work with such statements. But they also use logic to study the structure of mathematics. For example, one can study the structure, length, or complexity of proofs. In this way mathematicians use logic to study logic. In a broad sense, we are concerned with two things in mathematical logic. The first one is building new things out of old ones. We do this using the concept of a function. The second one is describing connections between chosen things. We do this using the concept of a relation. These two things is all we need for a definition of a language.
        </p>

        <div class="definition">
            A <b>language</b> is a triple \(\mathcal{L} = (\Gamma, \Delta, \Alpha) \) where 
            
            <ul>
                <li>\(\Gamma\) is a set of function symbols</li>
                <li>\(\Delta\) is a set of relation symbols</li>
                <li>\(\Alpha\) is a function assigning a natural number to every function and relation symbol</li>
            </ul>
        </div>

        <p>
            This doesn't look like a language at all. If you ask a linguist, they will shake their head over this definition. The triple \((\Gamma, \Delta, \Alpha)\) contains the so-called non-logical symbols, which we want to include in our theory. We will get to logical symbols later. The function \(\Alpha\) is called the arity function. Its domain is the set \(\Gamma \cup \Delta\) and its codomain is the set of natural numbers. The arity function simply describes the number of symbols the function or relation works with. Another common name for this triple is a signature, which is perhaps more fitting. For alphabet \(\Sigma\) we use distinct symbols called variables, parentheses, and a comma. This means that given variables \(\alpha,\beta\) and a function symbol \(f\) of arity two, we can construct a word \(f(\alpha,\beta)\). What is the general way of constructing words, or as a mathematician would say, terms?
        </p>

        <div class="definition">
            Let \(\mathcal{L} = (\Gamma, \Delta, \Alpha)\) be a language. The set of <b>terms</b> of \(\mathcal{L}\) is the smallest set of strings over the alphabet \(\Sigma\) satisfying the following
            <ul>
                <li>If \(x\) is a variable, then \(x\) is a term</li>
                <li>If \(c\) is a constant function symbol, then \(c\) is a term</li>
                <li>If \(f\) is a function symbol of arity \(n\) and \(t_1,\ldots,t_n\) are all terms, then \(f(t_1,\ldots,t_n)\) is a term</li>
            </ul>
        </div>

        <p>
            We now take a look at some simple languages and the terms we can write using these languages. The simplest language has no function or relation symbols at all. We can write such language as \(\mathcal{L}_\varnothing = (\varnothing, \varnothing, \Alpha)\) where \(\varnothing\) is the empty set. If you wonder whether the function \(\Alpha\) is well defined, then don't worry. It's perfectly fine to have a function with the empty set as its domain. So what are the terms of \(\mathcal{L}_\varnothing\)? The only way to build terms in this language is from variables. This means that terms of \(\mathcal{L}_\varnothing\) over a given alphabet \(\Sigma\) are exactly the variables of \(\Sigma\). If the alphabet does not contain any variables, then there are simply no terms.
        </p>

        <p>
            Let's make the language a little more interesting. We will write \(\mathcal{L}_1\) for a language where the only function symbol is \(f\) with arity one and the only relation symbol is \(r\) with arity two. In this language the arity function is defined as \(\Alpha(f) = 1\) and \(\Alpha(r) = 2\). To talk about terms, we need to specify the alphabet. A simple alphabet \(\Sigma_1\) consists of only one variable \(\alpha\). Having specified language and alphabet, we can start to write down the terms. For example, both \(\alpha\) or \(f(f(\alpha))\) are terms of this language and so is \(f(f(f(f(\alpha))))\).
        </p>

        <p>
            Bare terms are not enough to express anything meaningful. For that we need relations which give rise to formulas. If terms are like words, then you can think about formulas as sentences. Mathematicians even use the word sentence, but only for formula without free variable, which we will not discuss here. We still postpone the talk about logical symbols and define atomic formulas.
        </p>

        <div class="definition">
            Let \(\mathcal{L} = (\Gamma, \Delta, \Alpha)\) be a language. The set of <b>atomic formulas</b> of \(\mathcal{L}\) is the smallest set of strings over the alphabet \(\Sigma\) satisfying the following
            <ul>
                <li>If \(r\) is a relation symbol of arity \(n\) and \(t_1,\ldots,t_n\) are all terms, then \(r(t_1,\ldots,t_n)\) is an atomic formula</li>
            </ul>
        </div>

        <h3>How can we use a language</h3>

        <p>
            A function can be thought of as a recipe for modifying old things or creating new things out of old ones. For example squaring a number is a function. Another example might be a cooking recipe, where the input are the ingredients and the output is a sweet pie of your choosing. On the other hand relations express a connection between things. For example two people might be relatives, friends or colleagues. In all these examples these people are in some kind of relationship. How do we represent relations in mathematics? First we choose a set of things we want to talk about. Let's say that the set \(A = \{\alpha, \beta, \gamma, \delta, \epsilon, \pi, \omega, \zeta\}\) represents the greek letters we know. The set \(B = \{\pi, \omega\}\) then represents greek letters we like. We say that the set \(B\) defines a relation on the set \(A\). The letters \(\pi\) and \(\omega\) are related - we like both letters. Note that we can write a function \(f\) which specifies how to choose the set \(B\) from the set \(A\). The function \(f\) is simply defined as \(f(\pi) = \top\), \(f(\omega) = \top\) and \(\bot\) otherwise. You can thing about the symbols \(\top\), which represents truth, and \(\bot\), which represents falsity as indicators whether the letter belongs to the set \(B\). You might think that we don't need relations at all if every relation can be written as a function and you are right. You can indeed just use functions. The idea is to separate function symbols you want to use in the language from things representing relations in order to make the distinction clearer.
        </p>

        <p>
            Why the definitions of terms and formulas use function symbols and relation symbols? The reason is that we want to have the freedom to specify the actual functions and relations later. Think about it as some kind of templates or interfaces in programming languages. When declaring a language \(\mathcal{L}\), you define the arity of function symbol \(f\) to be two, but you do not have to say whether the function symbol \(f\) represents addition or multiplication. The process of specifying the concrete implementation of language symbols is connected to an idea of a model.
        </p>

        <h2>Model theory</h2>
        <h3>What is a model</h3>

        <p>
            To define a model for a language, we need couple more things. First we need a language and an alphabet. We also need a set which will be used as a domain and codomain for all interpreted functions. Finally the model has to specify how we interpret every function symbol and every relation symbol.
        </p>

        <div class="definition">
        Fix a language \(\mathcal{L} = (\Gamma,\Delta,\Alpha)\). We say that \(\mathcal{M} = (\mathcal{U},\mathcal{I})\) is a <b>model</b> for language \(\mathcal{L}\) if the set \(\mathcal{U}\), commonly called universe, is a nonempty set and \(\mathcal{I}\) is a function which assigns to each k-ary function symbol in \(\Gamma\) a k-ary function from \(\mathcal{U}\) to \(\mathcal{U}\) and to each k-ary relation symbol in \(\Delta\) a k-ary relation on \(\mathcal{U}\).
        </div>

        <p>
            Let's take again the language \(\mathcal{L}_1\) with one function symbol and one relation symbol and a universe \(\mathcal{U}\) consisting of natural numbers. We will define two models for this language. Both models will interpret the function symbol \(f\) as adding a fixed natural number to the function's operand. The model \(\mathcal{M}_1\) will interpret the relation symbol as the greater or equal relation and the function symbol as adding number \(1\) to the argument. This can be written as \(\mathcal{M}_1 = (\mathbb{N}, \mathcal{I}_1)\) where \(\mathcal{I}_1(f) = (+1)\) and \(\mathcal{I}_1(r) = (\geq)\). Now the second model \(\mathcal{M}_2\) will interpret the relation symbol as the divisibility relation and the function symbol as adding the number \(3\) to the argument. We can write the second model as \(\mathcal{M}_2 = (\mathbb{N}, \mathcal{I}_2)\) where \(\mathcal{I}_2(f) = (+3)\) and \(\mathcal{I}_2(r) = (\: | \:)\).
        </p>

        <p>
            Although these models share the same language, they interpret the language in different ways. For example we have \(4 \geq 3\), but not \(4 \:|\: 3\). This shows that things which are true in one model might not necessarily be true in another. Let's interpret the atomic formula \(r(f(f(a)),b)\) in the first model. The term \(f(f(a))\) is interpreted as \(a + 2\) as we add the number 1 two times. We cannot interpret the second term any further. We conclude that the formula is interpreted as \(a + 2 \:|\: b\). Can we say that the interpretation is true? Well it depends on how we interpret the variables. For example if \(a\) is \(1\) and \(b\) is \(9\), then the interpretation is true as 3 divides 9. We conclude that we need to interpret not only function and relation symbols, but also the variables. The transition from variables to elements of a universe is expressed by the assignment function.
        </p>

        <div class="definition">
            Fix a alphabet \(\Sigma\). The assignment function \(v\) is a function from the set of variables in \(\Sigma\) to the universe \(\mathcal{U}\).
        </div>

        <p>
            We have seen that there exists model and an assignment function which makes the interpretation of a formula true. This is the example of \(r(f(f(a)),b)\). Now the interpretation of a formula \(r(a,a)\) given the model \(\mathcal{M}_1\) is true for any assignment function as any number is less than or equal to itself. This makes the formula \(r(a,a)\) more interesting than the formula \(r(f(f(a)),b)\) as it is independent of the assignment function. Finally a formula which is independent of the specification of an underlying model is even more interesting. These notions are formalized in the following definition.
        </p>

        <div class="definition">
            We say that the atomic formula \(\mathfrak{f}\)
            <ul>
                <li>is <b>satisfiable</b> in the model \(\mathcal{M}\) if there exists an assignment that renders the formula to \(\top\). We write this as \(\mathcal{M} \vDash \mathfrak{f}[v]\).</li>
                <li>is <b>true</b> in the model \(\mathcal{M}\) if every assignment renders the formula to \(\top\). We write this as \(\mathcal{M} \vDash \mathfrak{f}\).</li>
                <li>is <b>valid</b> or a <b>semantic tautology</b> if it is true in every model for a given language \(\mathcal{L}\). We write this as \(\large \varnothing \normalsize \vDash \mathfrak{f}\).</li>
            </ul>
        </div>

        <h3>Tautologies</h3>
        <p>
            You might wonder why I did not give an example of an tautology for the \(\mathcal{L}_1\) language. The reason is that this language does not have any semantic tautologies. Why? Because there are too many models. Let's say we have a formula \(\mathfrak{f}\) which is true in a model \(\mathcal{M}_1\). This means that the interpretation is true for every possible assignment function. Now we add another symbol to the universe \(U\) and adjust the interpretation of relation in the language \(\mathcal{L}_1\) such that this symbol is not related to any other one. For example we can add the symbol \(i\) to the set of natural numbers. We will call this extended model \(\mathcal{M}_i\). Now we adjust the function symbol so that it is interpreted as doing nothing on the symbol \(i\) and the relation symbol is interpreted as false if at least one of the terms is interpreted as \(i\). The interpretation for other symbols for the universe is the same as in the model \(\mathcal{M}_1\). The formula \(\mathfrak{f}\) is not true in the extended model \(\mathcal{M}_i\) because of the interpretation of the symbol \(i\). It's still satisfiable as we can take any assignment function which does not contain \(i\). The formula \(r(a,a)\) is satisfiable in \(\mathcal{M}_i\) as for example \(2 \leq 2\) still holds. But the formula is not true because \(i \leq i\) does not hold by definition.
        </p>

        <p>
            We can extend this process to any language, not just \(\mathcal{L}_1\). This means that there exists no truthful atomic formula at all. But you have probably heard of tautologies, so where is the catch? The answer is the introduction of logical symbols. As symbols they need to be interpreted, but they are interpreted in a slightly different way than function symbols or relation symbols as we will see soon. There are quite few logical symbols but our set of logical symbols will consist of \(\land\), \(\lor\), \(\to\) and \(\bot\) which stand for conjunction, disjunction, implication and falsity. Equipped with logical symbols, we can give a definition of a formula.
        </p>

        <div class="definition">
            Let \(\mathcal{L} = (\Gamma, \Delta, \Alpha)\) be a language. The set of <b>formulas</b> of \(\mathcal{L}\) is the smallest set of strings over the alphabet \(\Sigma\) satisfying the following
            <ul>
                <li>\(\bot\) is a formula</li>
                <li>If \(\mathfrak{f}\) is an atomic formula, then \(\mathfrak{f}\) is a formula</li>
                <li>If \(\mathfrak{f}\) and \(\mathfrak{g}\) are formulas, then \(\mathfrak{f} \land \mathfrak{g}\) is a formula</li>
                <li>If \(\mathfrak{f}\) and \(\mathfrak{g}\) are formulas, then \(\mathfrak{f} \lor \mathfrak{g}\) is a formula</li>
                <li>If \(\mathfrak{f}\) and \(\mathfrak{g}\) are formulas, then \(\mathfrak{f} \to \mathfrak{g}\) is a formula</li>
            </ul>
        </div>

        <p>
            We see that logical symbols connect formulas, which is why they are also called logical connectives. So why are logical symbols so special? The interpretation of logical symbol does not depend on the underlying model explicitly. The only important thing is whether the subformulas interpret to true or false.
        </p>

        <div class="definition">
                Let \(\mathcal{M} = (\mathcal{U},\mathcal{I})\) be any model. We interpret formulas as follows

                <ul>
                    <li>\(\mathcal{I}(\bot) = \bot\)</li>
                    <li>If \(\mathcal{I}(P) = \top\) and \(\mathcal{I}(Q) = \top\), then \(\mathcal{I}(P \land Q) = \top\), otherwise \(\mathcal{I}(P \land Q) = \bot\) </li>
                    <li>If \(\mathcal{I}(P) = \top\) or \(\mathcal{I}(Q) = \top\), then \(\mathcal{I}(P \lor Q) = \top\), otherwise \(\mathcal{I}(P \lor Q) = \bot\) </li>
                    <li>If \(\mathcal{I}(P) = \bot\) or \(\mathcal{I}(Q) = \top\), then \(\mathcal{I}(P \to Q) = \top\), otherwise \(\mathcal{I}(P \to Q) = \bot\) </li>
                </ul>
            </div>

        <p>
            Can we come up with tautology now? Yes we can. One of the simplest tautologies is \(P \to P\). If \(P\) interprets to true, then \(P \to P\) interprets to true. If \(P\) interprets to false, then again \(P \to P\) interprets to true. This is the power which logical connectives hold. No matter the model and assignment function, we can form tautologies. Note that we do not have to include the symbol \(\top\) in the set of logical symbols as \(\top\) would be just an abbreviation for tautology. How do we deal with negation of a formula? It turns out we can write \(\lnot P\) as \(P \to \bot\). You can check for yourself that negation of \(\top\) is same as writing \(\top \to \bot\) and negation of \(\bot\) is same as writing \(\bot \to \bot\).
        </p>
    </div>
</body>